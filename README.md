# 📘 Unity3D Action RPG 게임 프로젝트
<br>
<img align="right" width="420"
     src="https://github.com/user-attachments/assets/f708e033-4d3c-40df-9d77-1627c117a392"
     alt="Unity3D src" />


- 소개 영상: [포트폴리오 영상](https://www.youtube.com/watch?v=rzw9Piw8OtU&t=8s)
- 개발 기간: 2024.06.26 ~ 2024.11.04 (131일)
- 개발 인원: 1인
- 핵심 요약: 유니티 엔진을 활용한 3D Action RPG 게임
- 개발 환경:
  - 언어: C#
  - 엔진: Unity

<br clear="both"/>

# 📘목차
- [개발 계기](#개발-계기)
- [아쉬웠던 점](#아쉬웠던-점)
- [프로젝트에서 얻은 것](#프로젝트에서-얻은-것)
- [구현 내용](#구현-내용)
- [문제 해결 경험(트러블 슈팅)](#문제-해결-경험트러블-슈팅)
- [핵심 주요 코드](#핵심-주요-코드)

# 📘개발 계기
### 1. 2D를 넘어, 3D RPG 콘텐츠 개발에 도전

평소 즐겨 하던 게임들처럼 3D 애니메이션을 활용한  
액션과 연출을 직접 구현해 보고자 했으며,  
단순히 2D에서 구현했던 내용을 반복하는 것이 아니라  
카메라, 애니메이션, 공간 구성 등 
3D 환경에서만 마주할 수 있는 고민과 경험을 쌓기 위해 진행했습니다.


# 📘아쉬웠던 점

**요약**
- [1. AI 군집 제어 부재에 대한 아쉬움](#weak-arch)
- [2. 디자인 패턴의 필요성을 체감한 경험](#weak-optim)
- [3. 폴더 구조 설계의 중요성](#teak3)

---

### 1. AI 군집 제어 부재에 대한 아쉬움 <a id="weak-arch"></a>

군집 전투의 느낌은 냈지만, 전투에 참여하는 AI 전체를 중앙에서 관리하지 못하고  
각 AI가 개별 로직으로만 알아서 싸우는 구조였다는 점이 아쉬움으로 남았습니다.

이 아쉬움은 이후 언리얼 프로젝트에서 **중앙 토큰 관리 매니저**를 도입해  
전투 참여 AI를 통합적으로 관리하는 구조를 설계·구현하면서 보완할 수 있었습니다.


---

### 2. 디자인 패턴의 필요성을 체감한 경험 <a id="weak-optim"></a>

초기에는 UI 설계 시 UI와 로직이 1:1로 강하게 결합되어 있어,  
UI 기능이 늘어날수록 로직 클래스도 함께 비대해지는 문제가 발생했습니다.

이 경험을 계기로 이후 언리얼 프로젝트에서는 **MVVM 패턴**을 도입해  
UI와 로직을 분리하는 방향으로 설계를 개선했습니다.

---

### 3. 폴더 구조 설계의 중요성 <a id="teak3"></a>

초기에는 스크립트를 역할 기준이 아니라, 그때그때 만든 **기능 단위**로 폴더를 나누다 보니  
매니저 스크립트가 대화 관련 폴더 안에 섞이는 등 전체 구조가 복잡해지는 문제가 있었습니다.

이 경험 이후 언리얼 액션 프로젝트에서는  
매니저, 컴포넌트, UI 등 **역할별로 폴더를 명확히 구분**하고,  
코드 구조를 처음부터 설계하며 진행하는 습관을 가지게 되었습니다.

# 📘프로젝트에서 얻은 것

**요약**
- [1. 렌더링 파이프라인 이해의 중요성](#project01)
- [2. 액션 로직 구현과 디자인 패턴 적용](#project02)
- [3. 3D 과정에서 새로 배운 것들](#project03)

---

### 1. 렌더링 파이프라인 이해의 중요성 <a id="project01"></a>

특히 런타임에 머티리얼을 투명 객체로 변경했는데도  
제대로 적용되지 않는 문제를 겪으면서,

렌더링 파이프라인에 대한 이해가 단순한 엔진 지식이 아니라  
**실제 콘텐츠 개발 결과와 직결되는 요소**라는 것을 몸으로 느낄 수 있었습니다.

---

### 2. 액션 로직 구현과 디자인 패턴 적용 <a id="project02"></a>

액션 게임에서 **공격 중 재입력 제한**, **다수 무기 관리** 같은 로직을 구현하면서  
이를 정리하기 위해 커맨드 패턴을 적용했습니다.

이 과정을 통해 디자인 패턴을 단순 이론이 아니라  
**실제 문제를 정리하고 해결하는 실전 도구**로 체득할 수 있었습니다.

---

### 3. 3D 과정에서 새로 배운 것들 <a id="project03"></a>

3D 개발에 진입하면서  
키프레임, 블렌딩, 애니메이션 이벤트를 직접 활용해 보고,  
여기에 더해 **루트 모션에 대한 이해까지 쌓을 수 있었던 경험**이었습니다.

# 📘구현 내용

- **플레이어 & 전투 시스템**  
  - 플레이어 움직임  
  - 원거리 / 근거리 / 듀얼 무기 시스템  
  - 무기별 스킬  
  - 회피, 저스트 회피, 암살 등 전투 기능  
  - 슬로우 모션, 잔상 등 전투 연출

- **AI & 보스 전투**  
  - 보스 전투 패턴 구현  
  - 등장 / 사망 연출  
  - 시네마틱과의 연계

- **UI & 상호작용**  
  - 스테미너 UI, 스킬 창 UI  
  - NPC 대화, 퀘스트 시스템  
  - 타겟팅, 마법진, 데미지 폰트, 카메라 연출

# 📘문제 해결 경험(트러블 슈팅)

**요약**
- [1. List.Contains(quest)에서 같은 퀘스트를 인식하지 못하는 문제](#tag01)
- [2. 자동 타겟팅 종료 후 카메라가 타겟팅 이전 회전 값으로 되돌아가는 문제](#tag02)
- [3. Transparent로 설정했는데 알파값을 조정해도 투명해지지 않는 문제](#tag03)
- [4. 앞으로 점프하는 Fist 스킬이 벽을 통과하거나 벽면에 딱 붙어 멈추는 문제](#tag04)
- [5. 다단히트 타이밍 문제](#tag05)

---

### 1. List.Contains(quest)에서 같은 퀘스트를 인식하지 못하는 문제 <a id="tag01"></a>

- 문제 상황
  
퀘스트 시스템 구현 중, 이미 진행 중인 퀘스트가 있는지 확인하기 위해  
`List.Contains(quest)`를 사용했지만, 같은 퀘스트임에도 리스트에서 동일한 대상으로 인식되지 않아  
퀘스트가 **중복 등록되는 문제**가 발생했습니다.

- 원인 분석
  
`Contains()`는 **참조(Reference) 비교**를 사용합니다.  
하지만 이 프로젝트에서는 UI에 표시되는 퀘스트를 ScriptableObject 기반으로  
**런타임에 인스턴스화**해서 사용했고, Active Quest List에도 매번 새로운 인스턴스를 추가하는 구조였습니다.  
그 결과, **같은 퀘스트라도 서로 다른 참조를 가진 객체**로 간주되어 중복 등록이 발생했습니다.

- 해결 방법
  
퀘스트를 “어떤 인스턴스인가(Reference)”가 아니라  
**“어떤 퀘스트인가(Logical Equality)”** 기준으로 비교하도록 변경했습니다.

모든 퀘스트에 고유 ID(`QuestID`)를 부여해  
`List.Contains()` 대신 **ID 기반 비교**로 동일 퀘스트 여부를 판별하게 했습니다.

- 결과
  
중복 퀘스트 등록 문제 해결  
퀘스트 완료 여부 및 보상 처리 로직이 **정상적으로 동작**

- 배운 점
  
현재 구조는 퀘스트를 `List`로 관리해, 삭제·이동 시마다 **선형 탐색(O(n))**이 필요했습니다.  
퀘스트 수가 많아질수록 비효율적이라는 점을 깨달았고,

이후 설계에서는 퀘스트를 고유 ID 기준으로 **`Dictionary`(HashMap)** 에 저장해  
조회·추가·삭제를 모두 **평균 O(1)** 로 처리하는 방식이 더 적절하다고 판단했습니다.

이 경험을 바탕으로, **언리얼 프로젝트의 아이템 관리 구조는 처음부터 해시 기반 컨테이너**를 사용하는 방향으로 설계했습니다.

---

### 2. 자동 타겟팅 종료 후 카메라가 타겟팅 이전 회전 값으로 되돌아가는 문제 <a id="tag02"></a>

- 문제 상황
  
자동 타겟팅 후, 원래 바라보던 방향으로 카메라가 튀듯이 되돌아가는 문제가 발생했습니다.

- 원인 분석
  
자동 타겟팅 중에는 마우스 입력으로 카메라를 돌리는 로직을 비활성화하고,  
타겟을 향하도록 카메라(또는 FollowTarget)를 직접 회전시키는 방식을 사용하고 있었습니다.

이때 실제 트랜스폼 회전 값은 계속 갱신되었지만,  
마우스 입력용으로 내부에 캐시해 두던 회전 값은 업데이트되지 않고  
타겟팅 이전 상태로 남아 있었기 때문이었습니다.  
타겟팅 종료 후 마우스 회전 로직이 다시 활성화되면서,  
카메라가 타겟팅 이전 방향으로 순간적으로 되돌아가는 현상이 발생했습니다.

- 해결
  
해결의 핵심은 “회전 기준을 하나로 맞추는 것”이었습니다.  
타겟팅이 종료되는 시점에, 타겟을 향하도록 변경된 회전 값을  
내부 캐시 값과 실제 트랜스폼에 동일하게 반영하도록 수정했습니다.

- 결과
  
타겟팅 해제 후에도 카메라가 바라보던 방향을 자연스럽게 유지하게 되었고,  
이전처럼 화면이 과거 방향으로 튀거나, 서서히 되돌아가는 이질감이 사라졌습니다.

- 배운 점
  
이 경험을 통해 단순히 값을 동기화하는 것보다,  
동기화가 많이 필요하지 않은 구조를 설계하는 것이 더 중요하다는 점을 깨달았습니다.

회전을 여러 곳에서 관리하면 동기화 포인트가 늘어나고,  
그만큼 자잘한 버그와 관리 비용도 함께 증가합니다.

그래서 이후에는 캐릭터든 카메라든 하나의 권위 있는 회전 주체를 명확히 정하고,  
나머지는 그 값을 참조만 하는 구조가 더 옳다고 생각하게 되었습니다.

---

### 3. Transparent로 설정했는데 알파값을 조정해도 투명해지지 않는 문제 <a id="tag03"></a>

- 문제 상황
  
사망한 오브젝트에 자연스러운 사망 연출을 넣기 위해,  
런타임에서 머티리얼의 Surface Type을 Transparent로 변경하고  
코드에서 Color.a 값을 줄여 오브젝트가 서서히 투명해지도록 구현하고자 했습니다.

하지만 알파 값은 분명히 변경되고 있음에도,  
실제 렌더링 결과에는 전혀 반영되지 않는 문제가 발생했습니다.

- 원인 분석
  
인스펙터에서 **Opaque → Transparent**로 변경할 때는,  
단순히 Surface Type만 바뀌는 것이 아니라 내부적으로

- 블렌딩 모드  
- ZWrite  
- Render Queue  
- 셰이더 키워드(`*_ALPHABLEND_ON*` 등)

과 같은 여러 렌더링 상태가 함께 변경됩니다.

하지만 저는 런타임에 인스펙터를 거치지 않고 **코드로 상태만 바꾸는 방식**을 사용했고,  
이 과정에서 위와 같은 내부 설정들은 그대로 Opaque에 가까운 상태로 남아 있었습니다.

그 결과, 알파 값 자체는 줄어들었지만  
렌더 파이프라인 입장에서는 여전히 “불투명 객체”처럼 처리되어  
투명해지지 않았던 것이 원인이었습니다.

- 해결
  
런타임에 **알파 값만** 변경하는 것이 아니라,  
투명 머티리얼로 동작하기 위해 필요한 렌더 상태를

- 블렌딩 모드  
- Render Queue  
- 관련 셰이더 키워드  

등과 함께 **명시적으로 설정**하도록 코드를 수정했습니다.

이후에는 머티리얼 설정이 한 번만 올바르게 잡히면,  
코드에서 `Color.a`만 조정해도 의도한 대로 서서히 사라지는 연출이 가능해졌습니다.

- 결과
  
보스 사망 시, 점점 투명해지며 사라지는 연출이  
인게임에서도 자연스럽게 표현되었고,

이 경험을 기반으로 이후 잔상 처리, UI용 3D 오브젝트, 이펙트 연출  
등 다른 투명 관련 연출에도 같은 원리를 재사용할 수 있는 기반을 마련했습니다.

- 배운 점
  
당시에는 그래픽스 파이프라인에 대한 이해가 부족해,  
문제의 원인을 파악하는 데 상당한 시간이 걸렸습니다.

이 경험을 통해, 게임 프로그래머라도 콘텐츠 로직만 이해해서는 부족하고,  
렌더링 파이프라인에 대한 기본적인 이해가 필수적이라는 점을 몸으로 느꼈습니다.

이를 계기로 “언제까지 엔진을 블랙박스로만 사용할 수는 없다”는 생각이 들었고,  
직접 그래픽 파이프라인을 설계해 보고자 DirectX 기반 자체 엔진을 개발하는 계기가 되었습니다.

---

### 4. 앞으로 점프하는 Fist 스킬이 벽을 통과하거나 벽면에 딱 붙어 멈추는 문제 <a id="tag04"></a>

- 문제 상황
  
앞으로 크게 점프하며 돌진하는 Fist 스킬을 구현했는데,  
일부 상황에서 캐릭터가 벽을 통과해버리거나,  
벽 바로 앞에서 멈추는 대신 벽에 딱 달라붙어 부자연스럽게 정지하는 문제가 발생했습니다.

특히 속도가 빠른 스킬 특성상,  
얇은 벽이나 콜라이더 모서리에서 뚫고 지나가는 느낌이 강하게 나타나  
플레이 감각과 충돌 처리 모두 만족스럽지 않았습니다.

- 원인 분석
  
처음 구현은 “지정된 거리만큼 앞으로 이동한다”는 개념에 가깝게,  
리지드바디 이동 또는 위치 보정을 사용해 프레임마다 일정 거리씩 앞 방향으로 밀어주는 방식이었습니다.

이때 문제가 된 지점은 두 가지였습니다.

**1) 빠른 속도 + FixedUpdate 간격 문제**  
캐릭터가 한 프레임 동안 이동하는 거리가 너무 길어지면,  
시작 지점과 끝 지점 사이에 있는 얇은 벽 콜라이더를  
물리 엔진이 건너뛰어버리는(터널링) 현상이 나타날 수 있습니다.

**2) 도착 지점을 그대로 Hit 지점으로 사용하는 설계**  
Ray를 사용해 벽을 감지하더라도,  
충돌 지점까지를 그대로 도착 위치로 쓰면 캐릭터가 벽에 과도하게 밀착되어 시각적으로 부자연스럽고,  
이후 이동이나 추가 충돌 처리에서 다시 문제를 일으킬 여지가 있었습니다.

결국, “정해진 거리만 가는 이동”과 “실제 충돌 지점” 사이의 관계를  
제대로 정리하지 않은 것이 근본 원인이었습니다.

- 해결
  
해결의 핵심은 **“이동을 먼저 하고 충돌에 맡기는 구조”에서  
“충돌을 먼저 예측하고, 그에 맞게 이동을 제한하는 구조”로 바꾸는 것**이었습니다.

- 스킬 사용 시 캐릭터의 전방으로 Ray를 발사해, 최대 스킬 거리까지 충돌체를 탐색  
- 충돌 지점까지의 거리에서 소량의 여유 거리(오프셋)를 뺀 거리만 이동  
- 충돌이 감지되지 않으면 원래 설계된 최대 스킬 거리까지 이동

이렇게 해서, 벽이 있으면 벽 바로 앞에서 자연스럽게 멈추고,  
벽이 없으면 원래 기획한 거리까지 돌진하는 형태로 동작하도록 수정했습니다.

이동 자체도 더 이상 “무작정 앞으로 Translate”하는 개념이 아니라,  
Raycast로 이동 가능 구간을 먼저 확정하고 그 범위 안에서 이동하는 구조로 정리했습니다.

- 결과
  
Fist 점프 스킬 사용 시 캐릭터가 벽을 관통하거나 콜라이더를 뚫는 현상이 사라졌고,  
벽에 딱 달라붙지 않고 적절한 거리 앞에서 멈추는 연출이 가능해졌습니다.

스킬 연출이 의도된 움직임처럼 보이게 되면서,  
플레이어 입장에서의 피드백도 훨씬 자연스럽고 안정적으로 느껴지게 되었습니다.

또한 같은 원리를 활용해, 이후 다른 돌진 계열 스킬이나 이동 스킬에도  
“이동 전에 Ray로 경로를 검증하는 패턴”을 재사용할 수 있는 기반이 마련되었습니다.

- 배운 점
  
물리 처리로도 해결할 수 있었지만, 그 방식은 결국 엔진 내부에서  
매 프레임마다 충돌을 확인하는 비용을 계속 지게 됩니다.  
이를 고려하다 보니, **미리 Ray를 쏴서 갈 수 있는 범위를 체크하는 방식**에 도달하게 되었습니다.

내부 엔진이 최소한 어떻게 동작하는지, 자원을 얼마나 소모하는지에 대한 이해가 없었다면  
이와 같은 선택에 도달하지 못했을 것 같습니다.

이 경험을 통해, 겉으로 보이는 콘텐츠 구현에만 집중하는 것이 아니라  
엔진 내부 동작과 아키텍처에 대한 학습도 중요하다고 다시 한 번 느끼게 되었습니다.

---

### 5. 다단히트 타이밍 문제 <a id="tag05"></a>

- 문제 상황
  
일정 시간 동안 히트 박스를 활성화하여 공격하는 장판형 스킬과  
Collider의 On/Off로 판정을 발생시키는 다단히트 스킬에서,  
몬스터가 여러 마리일 때 동시에 동일한 타이밍으로 피격되는 문제가 나타났습니다.

또한, 다단히트를 5회로 의도했음에도 6회 이상 히트가 발생하거나,  
고속 공격일 경우 히트가 누락되는 현상도 함께 발생했습니다.

이로 인해 피격 타이밍과 연출이 불안정해지고,  
공격이 의도대로 작동하지 않는 느낌을 주었습니다.

- 원인 분석
  
초기 구현 방식은 Collider를 주기적으로 On/Off하여  
충돌이 발생하면 데미지를 주는 구조였습니다.

문제는 여러 몬스터가 동일한 On 타이밍에 동시에 감지되어  
피격 타이밍이 전부 같아져 부자연스러웠고,

Unity의 충돌 판정은 FixedUpdate 주기(기본 0.02초)에 따라 처리되므로,  
매우 짧은 딜레이(예: 0.05초)로 판정을 반복하면  
시점이 겹쳐 1회 더 들어가거나 누락되는 상황이 발생했습니다.

즉, 단순히 Collider on/off에 의존하는 방식은  
정교한 다단히트 타이밍 제어에 적합하지 않았습니다.

- 해결
  
다단히트의 기준을 Collider 감지 여부가 아니라  
피격 시점 기록 기반의 시간 관리 방식으로 변경했습니다.

구체적으로

- 충돌 시 피격 대상 + 마지막 피격 시간을 저장  
- 현재 시간 - 마지막 피격 시간 >= hitDelay일 때만 피격 가능 처리  
- 피격 횟수를 Count하여 최대 횟수 제한

등으로 처리해 몬스터마다 서로 다른 타이밍으로 데미지가 적용하고,  
FixedUpdate 타이밍 오차로 인한 중복 판정 문제를 해결했습니다.

- 결과
  
다단히트가 **의도한 횟수와 간격으로 안정적으로 처리**되었고,  
몬스터가 여럿일 때도 **각각 개별적으로 피격 타이밍이 다르게 적용**되어  
연출과 타격감이 크게 향상되었습니다.

또한, Collider의 On/Off만으로 다단히트를 구현했을 때보다  
코드 유지보수가 훨씬 쉬워졌습니다.

- 배운 점
  
처음에는 “다단히트를 정밀하게 보장하려면 FixedUpdate에  
로직을 써야 한다”고 생각했지만, 실제로는 물리 틱에  
직접 의존한 설계가 오히려 잘못된 판정을 발생시킬 수 있다는 것을 경험했습니다.

이 일을 계기로, FixedUpdate의 역할과 한계를 다시 정리하게 되었고,  
이후에는 물리는 충돌 신호만 담당하고, 히트 판정과 타이밍은  
시간 기반 로직으로 분리하는 구조를 설계 원칙으로 삼게 되었습니다.

# 📘핵심 주요 코드
- 
